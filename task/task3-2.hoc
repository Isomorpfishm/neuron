// Task 3-2: A four-node neural network with randomness included
// NMODL: Gluct.mod, tmgsyn.mod

load_file("nrngui.hoc")

//----------------------------------------------------------------------------
//  create neuronal compartments and insert hh properties
//----------------------------------------------------------------------------

begintemplate SThcell

public soma, dend0, dend1, axon, nclist, ap
create soma, dend0, dend1, axon, ap
objectvar nclist

proc init() { local i
	nsegdend = $1

	create soma, dend0, dend1, axon, ap
	nclist = new List()

	soma {
		nseg = 5
		diam = 20
		L = 20
		Ra = 160
		cm = 1
		insert hh
	}

	ap {
		nseg = nsegdend
		diam = 2.0
		L = 400
		Ra = 160
		cm = 1
		insert hh
	}

	dend0 {
		nseg = nsegdend
		diam = 1.0
		L = 300
		Ra = 160
		cm = 1
		insert hh
	}

	dend1 {
		nseg = nsegdend
		diam = 1.0
		L = 500
		Ra = 160
		cm = 1
		insert hh
	}

	axon {
    		nseg = 50
    		diam = 1
    		L = 1000
    		cm = 1
    		insert hh
	}

	// Connect things together
	connect soma(1), axon(1)
	connect ap(1), soma(0)
	connect dend0(1), ap(0)
	connect dend1(1), ap(0)
}
endtemplate SThcell



//----------------------------------------------------------------------------
//  neurons alignment
//----------------------------------------------------------------------------

// create twelve new neurons with 30 segments
nSThcells = 12
objectvar SThcells[nSThcells]

for i = 0, nSThcells-1 {
	SThcells[i] = new SThcell(30)
}

// define spatial arrangement
for i = 0, 2 {
	SThcells[i].soma {
		pt3dclear()
		pt3dadd(-10, 410, 40*i, 20)
		pt3dadd(10, 410, 40*i, 20)
	}
	SThcells[i].axon {
		pt3dadd(10, 410, 40*i, 1)
		pt3dadd(1010, 410, 40*i, 1)
	}
}

for i = 3, 5 {
	SThcells[i].soma {
		pt3dclear()
		pt3dadd(1010, 10, 40*(i-3), 20)
		pt3dadd(1010, -10, 40*(i-3), 20)
	}
	SThcells[i].axon {
		pt3dadd(1010, -10, 40*(i-3), 1)
		pt3dadd(1010, -1010, 40*(i-3), 1)
	}
}

for i = 6, 8 {
	SThcells[i].soma {
		pt3dclear()
		pt3dadd(610, -1010, 40*(i-6), 20)
		pt3dadd(590, -1010, 40*(i-6), 20)
	}
	SThcells[i].axon {
		pt3dadd(590, -1010, 40*(i-6), 1)
		pt3dadd(-410, -1010, 40*(i-6), 1)
	}
}

for i = 9, 11 {
	SThcells[i].soma {
		pt3dclear()
		pt3dadd(-410, -610, 40*(i-9), 20)
		pt3dadd(-410, -590, 40*(i-9), 20)
	}
	SThcells[i].axon {
		pt3dadd(-410, -590, 40*(i-9), 1)
		pt3dadd(-410, 410, 40*(i-9), 1)
	}
}



//----------------------------------------------------------------------------
//  create intranodal and internodal synapses
//----------------------------------------------------------------------------

// define the source of events for a synapse
// FORMAT: new NetCon(&source_v, synapse, threshold, delay, weight)

// 12 neurons with maximum 20 intranodal and internodal synapses each
objectvar syn[240], sym[240], r_inter, r_intra

for i = 0, 11 {
	for j = 1, 20 {
		SThcells[i].dend0 syn[20*i + j - 1] = new ExpSyn(0)
		SThcells[i].dend1 sym[20*i + j - 1] = new ExpSyn(0)
	} 
}

r_inter = new Random()
r_intra = new Random()

for (i = 0; i <= 11; i = i + 1) {
	k1 = r_inter.discunif(0, 10)
	k2 = r_inter.repick()
	k3 = r_intra.discunif(0, 20)

	k = 1 

	if (i == 0 || i == 3 || i == 6 || i == 9) {
		p = i + 1
		q = i + 2
		temp = 0
	}

	if (i == 1 || i == 4 || i == 7 || i == 10) {
		p = i - 1
		q = i + 1
		temp = 1
	}

	if (i == 2 || i == 5 || i == 8 || i == 11) {
		p = i - 1
		q = i - 2
		temp = 2
	}

	while (k <= k1 || k <= k2) {
		if ((k > k1 && k <= k2) || (k <= k1 && k <= k2)) {
			wei_up = r_inter.uniform(0.0001, 1)
			delay_up = r_inter.discunif(1, 5)
			SThcells[i].soma SThcells[p].nclist.append(new NetCon(&v(1), syn[20*i + k - 1], -55, delay_up, wei_up))
			print "intra-syp from the soma of neuron ", i, " appended to dend0 of neuron ", p, " - even perm"
		}
		if ((k > k2 && k <= k1) || (k <= k1 && k <= k2)) {
			wei_down = r_inter.uniform(0.0001, 1)
			delay_down = r_inter.discunif(1, 5)
			SThcells[i].soma SThcells[q].nclist.append(new NetCon(&v(1), syn[20*i + 10 + k - 1], -55, delay_down, wei_down))
			print "intra-syp from the soma of neuron ", i, " appended to dend0 of neuron ", q, " - odd perm"
		}
		k += 1		
	}

	for (k = 1; k <= k3; k = k + 1) {
		wei = r_intra.uniform(0.0001, 1)
		delay = r_intra.uniform(1, 5)

		if (k % 3 == 0) {
			arg = (i+3-temp)%12
			print "inter-syp from the axon of neuron ", i, " appended to dend1 of neuron ", arg, " +0 loop"
		}
		if (k % 3 == 1) {
			arg = (i+4-temp)%12
			print "inter-syp from the axon of neuron ", i, " appended to dend1 of neuron ", arg, " +1 loop"
		}
		if (k % 3 == 2) {
			arg = (i+5-temp)%12
			print "inter-syp from the axon of neuron ", i, " appended to dend1 of neuron ", arg, " +2 loop"
		}

		SThcells[i].axon SThcells[arg].nclist.append(new NetCon(&v(0), sym[20*i + k - 1], -55, delay, wei))
	}
	print "-----< Neuron ", i, "has ", k1, "even ", k2, "odd intra-syp resp and ", k3, "inter-syp >-----"
}



//----------------------------------------------------------------------------
// insert Gfluct and IClamp point processes
//----------------------------------------------------------------------------

objref fl[nSThcells]
objectvar stim[nSThcells]

for (i = 0; i <= 11; i = i + 1) {
	SThcells[i].axon fl[i] = new Gfluct2(0.5)
	fl[i].std_e = 0.012
	fl[i].std_i = 0.0264
}

for (i = 0; i <= 2; i = i + 1) SThcells[i].axon {
	stim[i] = new IClamp(0.4)
	stim[i].del = 2*i
	stim[i].dur = 2
	stim[i].amp = 10
}

access SThcells[0].soma
xopen("task3.ses")
